library(tidyverse)
library(readr)
library(corrplot)
library(ggbiplot)


library(tidymodels)
library(infer)
library(devtools)

library(sf)
library(corrplot)
library(tmap)
library(spdep)
library(spgwr)
library(RColorBrewer)

library("factoextra")

setwd("~/R/Birmingham&Walsall/Week5") 
dir()

Townsend_prepared <- read_csv("Townsend_prepared.csv") %>% filter(!if_any(everything(), ~is.na(.x)))
Manufacturing_prepared <- read_csv("Manufacturing_prepared.csv") %>% filter(!if_any(everything(), ~is.na(.x)))

data <- Manufacturing_prepared %>% select(year:prop_sick) %>% left_join(Townsend_prepared %>% select(year:prop_no_car)) %>% 
  select(-c(year,lsoa21)) %>% filter(!if_any(everything(), ~is.na(.x)))

#data == distinct(data)
#### Whole sample clusters (each area is represented multiple times - once for each census date at which it is not NA) ####
kclust <- kmeans(data, centers = 5)

kclust
summary(kclust)

# This adds the cluster information back onto the data
augment(kclust, data)

# Per cluster level summary (averages of each variable, size of cluster and withinss)
tidy(kclust)

# Statistics total ss, within and between and number of iterations
glance(kclust)

#### Lets look at a range of possible number of clusters using dplyr k = 1 to k = 10

# It's important that the data is a tibble ?!!?
data <- tibble(data)

kclusts <- tibble(k = 1:10) %>%
  mutate(kclust = map(k, ~kmeans(data, .x)), tidied = map(kclust, tidy), glanced = map(kclust, glance), augmented = map(kclust, augment, data))

# Note this is a 10 x 5 object with lists/tibbles in columns 2-5
kclusts 

# This contains a summary of the clusters for each value of k. There are n rows for n =3, 
clusters <- kclusts %>% unnest(cols = c(tidied))

# This contains all of the points for each k, labeled with the cluster they belong to
assignments <- kclusts %>% unnest(cols = c(augmented)) 

# This contains summary stats for each... 
clusterings <- kclusts %>% unnest(cols = c(glanced)) 

### Elbow Plot 
ggplot(clusterings, aes(k, tot.withinss)) + geom_line() + geom_point()
# This suggests that the idea number of clusters is likely to be k =  3

#install.packages("factoextra") 


# Silhouette analysis
fviz_nbclust(data, kmeans, method = "silhouette")


### Visualisation 
# As we have more than two variables describing each point, to visualise the clusters I am going to take three approaches

# (1) Pick some pairs of variables and see what we get!

colnames(assignments)
plot <-  ggplot(assignments, aes(x = prop_manufacturing, y = prop_unemployed)) + geom_point(aes(color = .cluster), alpha = 0.8) + facet_wrap(~ k, nrow =5)

plot 

##########################
### View all for k = 2 ###
##########################

assignments_2 <- assignments %>% filter(k == 2) %>% select(prop_manufacturing:.cluster) %>%
  pivot_longer(prop_manufacturing:prop_sick, names_to = "M_component", values_to = "M_proportion") %>%
  pivot_longer(prop_unemployed:prop_no_car, names_to = "T_component", values_to = "T_proportion") %>%
  mutate(M_component = str_remove(M_component, pattern = "prop_"), T_component = str_remove(T_component, pattern = "prop_"))

ggplot(assignments_2, aes(x = T_proportion, y = M_proportion)) + geom_point(aes(color = .cluster), alpha = 0.8) + 
  facet_grid(rows = vars(M_component), cols = vars(T_component), scales = "free")

# (2) PCA on the joint data and represent in this space

pca_data <- assignments %>% filter(k == 2) %>% select(prop_manufacturing:.cluster)

pc <- prcomp(pca_data[,-10], center = TRUE, scale. = TRUE)
print(pc)
summary(pc)

biplot <- ggbiplot(pc, obs.scale = 1, var.scale = 1,
              groups = pca_data$.cluster,
              ellipse = TRUE,
              circle = TRUE,
              ellipse.prob = 0.68)
biplot <- biplot + scale_color_discrete(name = '')
biplot <- biplot + theme(legend.direction = 'horizontal',
               legend.position = 'top')

biplot

# (3) Reconnect the data with the indices and represent in this space

index_data <- assignments %>% filter(k == 2) %>% select(prop_manufacturing:.cluster) %>% 
  inner_join(Townsend_prepared %>% select(year:Townsend_index)) %>% #Warning generated by the way we filled in missing data
  inner_join(Manufacturing_prepared %>% select(year:Manufacturing_index)) 

ggplot(index_data, aes(x = Manufacturing_index, y = Townsend_index, color = .cluster)) + geom_point()

##############################
#### Review all for k = 4 ####
##############################

# Filter for useful statistics

Table1 <- clusters %>% filter(k ==4)

Table2 <- clusterings %>% filter(k ==4)

# (1) Choice of pair of elements

assignments_4 <- assignments %>% filter(k == 4) %>% select(prop_manufacturing:.cluster) %>%
  pivot_longer(prop_manufacturing:prop_sick, names_to = "M_component", values_to = "M_proportion") %>%
  pivot_longer(prop_unemployed:prop_no_car, names_to = "T_component", values_to = "T_proportion") %>%
  mutate(M_component = str_remove(M_component, pattern = "prop_"), T_component = str_remove(T_component, pattern = "prop_"))

ggplot(assignments_4, aes(x = T_proportion, y = M_proportion)) + geom_point(aes(color = .cluster), alpha = 0.8) + 
  facet_grid(rows = vars(M_component), cols = vars(T_component), scales = "free")

# (2) PCA on the joint data and represent in this space

pca_data <- assignments %>% filter(k == 4) %>% select(prop_manufacturing:.cluster)

pc <- prcomp(pca_data[,-10], center = TRUE, scale. = TRUE)
print(pc)
summary(pc)

biplot <- ggbiplot(pc, obs.scale = 1, var.scale = 1,
                   groups = pca_data$.cluster,
                   ellipse = TRUE,
                   circle = TRUE,
                   ellipse.prob = 0.68)
biplot <- biplot + scale_color_discrete(name = '')
biplot <- biplot + theme(legend.direction = 'horizontal',
                         legend.position = 'top')

biplot

# (3) Reconnect the data with the indices and represent in this space

index_data <- assignments %>% filter(k == 4) %>% select(prop_manufacturing:.cluster) %>% 
  inner_join(Townsend_prepared %>% select(year:Townsend_index_year)) %>% #Warning generated by the way we filled in missing data
  inner_join(Manufacturing_prepared %>% select(year:Manufacturing_index_year)) 

# Total plot with relative index 
ggplot(index_data, aes(x = Manufacturing_index, y = Townsend_index, color = .cluster)) + geom_point()

# Relative index facets
ggplot(index_data, aes(x = Manufacturing_index, y = Townsend_index, color = .cluster)) + geom_point() + facet_wrap(~year, ncol = 3)

# Geographical clusters facets
Birmingham_2021 <- read_sf("~/R/Birmingham&Walsall/Week3/Lower_layer_Super_Output_Areas_(December_2021)_Boundaries_EW_BFC_(V10).shp") %>% 
  filter(str_detect(LSOA21NM, "Birmingham")) 

geographical_data <- Birmingham_2021 %>% right_join(index_data, by = c("LSOA21CD" = "lsoa21")) %>% mutate(.cluster = fct_drop(.cluster))

Clusters_map <- tm_shape(geographical_data) + tm_fill(col = ".cluster", style = "cat", palette = "brewer.pu_or", col.legend = tm_legend(show = FALSE)) + tm_borders(alpha = 0.4) + tm_facets_wrap("year", nrow =2)

tmap_save(Clusters_map, 
          filename = "~/R/Birmingham&Walsall/Poster_materials/Clusters_map.png",
          width = 3000,
          height = 3000,
          dpi = 300)

######################################
### Clustering for each time point ###
######################################

### Test case! 2021 ###

data_2021 <- Manufacturing_prepared %>% select(year:prop_sick) %>% left_join(Townsend_prepared %>% select(year:prop_no_car)) %>% filter(year == 1971) %>%
  filter(!if_any(everything(), ~is.na(.x))) 

# Only Manufacturing
data_2021 <- Manufacturing_prepared %>% select(year:prop_sick) %>% filter(year == 1971) %>%
  filter(!if_any(everything(), ~is.na(.x))) 

data_2021 <- Townsend_prepared %>% select(year:prop_no_car) %>% filter(year == 1971) %>%
  filter(!if_any(everything(), ~is.na(.x))) 

data_test <- data_2021 %>% select(-year, -lsoa21)

# It's important that the data is a tibble ?!!?
data_test <- tibble(data_test)

kclusts <- tibble(k = 1:10) %>%
  mutate(kclust = map(k, ~kmeans(data_test, .x)), tidied = map(kclust, tidy), glanced = map(kclust, glance), augmented = map(kclust, augment, data_test))

# Note this is a 10 x 5 object with lists/tibbles in columns 2-5
kclusts 

# This contains a summary of the clusters for each value of k. There are n rows for n =3, 
clusters <- kclusts %>% unnest(cols = c(tidied))

# This contains all of the points for each k, labeled with the cluster they belong to
assignments <- kclusts %>% unnest(cols = c(augmented)) 

# This contains summary stats for each... 
clusterings <- kclusts %>% unnest(cols = c(glanced)) 

### Elbow Plot 
ggplot(clusterings, aes(k, tot.withinss)) + geom_line() + geom_point()
# This suggests that the idea number of clusters is likely to be 2-4

# Silhouette analysis
fviz_nbclust(data_test, kmeans, method = "silhouette") # Optimal choice still k = 2

# This is quite boring as there are only 2 clusters for all years

##############################
### Using lagged variables ###
##############################

str(Manufacturing_prepared)

#Function to change names and column bind

# list of LSOA21s as a df

df <- Manufacturing_prepared %>% select(lsoa21) %>% distinct()

Add_year <- function(df, y){
  data_year <- Manufacturing_prepared %>% select(year:prop_sick) %>% filter(year == y) %>% 
    select(-year) %>%
    rename_with(~ paste0(y, "_", .x), prop_manufacturing:prop_sick)
  df %>% left_join(data_year)
}

Add_year2 <- function(df, y){
  data_year <- Townsend_prepared %>% select(year:prop_no_car) %>% filter(year == y) %>% 
    select(-year) %>%
    rename_with(~ paste0(y, "_", .x), prop_unemployed:prop_no_car)
  df %>% left_join(data_year)
}

df <- df %>% Add_year(2021) %>% Add_year(2011) %>% Add_year(2001) %>% Add_year(1991) %>% Add_year(1981) #%>% Add_year(1971)
df <- df %>% Add_year2(2021) %>% Add_year2(2011) %>% Add_year2(2001) %>% Add_year2(1991) %>% Add_year2(1981) %>% Add_year2(1971)

str(df)

## K-means on areas only

data_test <- df %>% filter(!if_any(everything(), ~is.na(.x))) %>% select(-lsoa21)

# It's important that the data is a tibble ?!!?
data_test <- tibble(data_test)

kclusts <- tibble(k = 1:10) %>%
  mutate(kclust = map(k, ~kmeans(data_test, .x)), tidied = map(kclust, tidy), glanced = map(kclust, glance), augmented = map(kclust, augment, data_test))

# Note this is a 10 x 5 object with lists/tibbles in columns 2-5
kclusts 

# This contains a summary of the clusters for each value of k. There are n rows for n =3, 
clusters <- kclusts %>% unnest(cols = c(tidied))

# This contains all of the points for each k, labeled with the cluster they belong to
assignments <- kclusts %>% unnest(cols = c(augmented)) 

# This contains summary stats for each... 
clusterings <- kclusts %>% unnest(cols = c(glanced)) 

### Elbow Plot 
ggplot(clusterings, aes(k, tot.withinss)) + geom_line() + geom_point()
# This suggests that the idea number of clusters is likely to be 2-4

# Silhouette analysis
fviz_nbclust(data_test, kmeans, method = "silhouette")

# Geographical plot
Birmingham_2021 <- read_sf("~/R/Birmingham&Walsall/Week3/Lower_layer_Super_Output_Areas_(December_2021)_Boundaries_EW_BFC_(V10).shp") %>% 
  filter(str_detect(LSOA21NM, "Birmingham")) 

df_k3 <- assignments %>% filter(k == 2) %>% mutate(.cluster = fct_drop(.cluster)) %>% inner_join(df) #Warning generated by the way we filled in missing data

geographical_data <- Birmingham_2021 %>% right_join(df_k3, by = c("LSOA21CD" = "lsoa21")) %>% mutate(.cluster = fct_drop(.cluster))

lagged_map <- tm_shape(geographical_data) + tm_fill(col = ".cluster", style = "cat", palette = "brewer.pu_or", col.legend = tm_legend(show = FALSE)) + tm_borders(alpha = 0.4) 

tmap_save(lagged_map, 
          filename = "~/R/Birmingham&Walsall/Poster_materials/lagged_map.png",
          width = 3000,
          height = 3000,
          dpi = 300)

### Faceted graph of components

# Re-join lagged clustering to long data for easier facets
df_long <- Manufacturing_prepared %>% select(year:prop_sick) %>% 
  left_join(Townsend_prepared %>% select(year:prop_no_car)) %>% 
  inner_join(df_k3 %>% select(lsoa21, .cluster))

df_longer <- df_long %>% pivot_longer(prop_manufacturing:prop_sick, names_to = "M_component", values_to = "M_proportion") %>%
  pivot_longer(prop_unemployed:prop_no_car, names_to = "T_component", values_to = "T_proportion") %>%
  mutate(M_component = str_remove(M_component, pattern = "prop_"), T_component = str_remove(T_component, pattern = "prop_"))

df_longer %>% filter(year == 2021) %>% ggplot(aes(x = T_proportion, y = M_proportion)) + geom_point(aes(color = .cluster), alpha = 0.8) + 
  facet_grid(rows = vars(M_component), cols = vars(T_component), scales = "free")

### Mean proportions is a big horrid but lets take a look
df_long %>% mutate(year = as.factor(year)) %>% group_by(year, .cluster) %>% 
  summarise(across(starts_with("prop_"), ~mean(.x))) %>% pivot_longer(starts_with("prop_"), names_to = "Component", values_to = "mean_proportion") %>%
  mutate(Component = str_remove(Component, "prop_")) %>%
  ggplot(aes(x = year, y = mean_proportion, group = Component)) + geom_line() + facet_grid(cols = vars(.cluster), rows = vars(Component))  

#############################################
#### Load labels from other file 
#############################################

test <- read_csv("~/R/Birmingham&Walsall/Week5/labels.csv")

df_labels <- df %>% inner_join(test %>% select(lsoa21, k_2)) %>% filter(!if_any(everything(), ~is.na(.x))) %>% select(-lsoa21) %>% group_by(k_2) %>% nest() 
str(df_labels)

kclusts <- df_labels %>% mutate(kclust = map(data, ~kmeans(.x, 2)), tidied = map(kclust, tidy), glanced = map(kclust, glance), augmented = map2(kclust, data, augment))

# Note this is a 3 x 6 object with lists/tibbles in columns 2-5
kclusts 

# This contains a summary of the clusters for each value of k. There are n rows for n =3, 
clusters <- kclusts %>% unnest(cols = c(tidied))

# This contains all of the points for each k, labeled with the cluster they belong to
assignments <- kclusts %>% unnest(cols = c(augmented)) 

# This contains summary stats for each... 
clusterings <- kclusts %>% unnest(cols = c(glanced)) 

### Elbow Plot for each subgroup
for(i in 1:2){
  data <- df_labels %>% unnest(cols = c(data)) %>% filter(k_2 == i) 
  plot <- fviz_nbclust(data, kmeans, method = "wss")
  print(plot)
}

# Silhouette analysis
for(i in 1:2){
  data <- df_labels %>% unnest(cols = c(data)) %>% filter(k_2 == i) 
  plot <- fviz_nbclust(data, kmeans, method = "silhouette")
  print(plot)
}

df_partition <- assignments %>% mutate(.cluster = as.factor(str_c(k_2, ".", .cluster))) %>% ungroup() %>% select(-(k_2:glanced)) %>% inner_join(df)
summary(df_partition$.cluster)
geographical_data <- Birmingham_2021 %>% right_join(df_partition, by = c("LSOA21CD" = "lsoa21")) 


partitioned_map <- tm_shape(geographical_data) + tm_fill(col = ".cluster", style = "cat", palette = "brewer.paired", col.legend = tm_legend(show = FALSE)) + tm_borders(alpha = 0.4) 

#tmap_save(partioned_map, 
#          filename = "~/R/Birmingham&Walsall/Poster_materials/partitioned_map.png",
#          width = 3000,
#          height = 3000,
#          dpi = 300)

df_long <- Manufacturing_prepared %>% select(year:prop_sick) %>% 
  left_join(Townsend_prepared %>% select(year:prop_no_car)) %>% 
  inner_join(df_partition %>% select(lsoa21, .cluster))

### Mean proportions is a big horrid but lets take a look
df_long %>% mutate(year = as.factor(year)) %>% group_by(year, .cluster) %>% 
  summarise(across(starts_with("prop_"), ~mean(.x))) %>% pivot_longer(starts_with("prop_"), names_to = "Component", values_to = "mean_proportion") %>%
  mutate(Component = str_remove(Component, "prop_")) %>%
  # ggplot(aes(x = year, y = mean_proportion, group = Component)) + geom_line() + facet_grid(cols = vars(.cluster), rows = vars(Component))  
  ggplot(aes(x = year, y = mean_proportion, group = Component, color = Component)) + geom_line() + facet_wrap(~.cluster)

# Which of these components are significantly different between the groups? 

### 

df_longer <- df_long %>% pivot_longer(prop_manufacturing:prop_sick, names_to = "M_component", values_to = "M_proportion") %>%
  pivot_longer(prop_unemployed:prop_no_car, names_to = "T_component", values_to = "T_proportion") %>%
  mutate(M_component = str_remove(M_component, pattern = "prop_"), T_component = str_remove(T_component, pattern = "prop_"))

df_longer %>% filter(year == 2001) %>% ggplot(aes(x = T_proportion, y = M_proportion)) + geom_point(aes(color = .cluster), alpha = 0.6) + 
  facet_grid(rows = vars(M_component), cols = vars(T_component), scales = "free")

# (2) PCA on the joint data and represent in this space

pca_data <- df_partition %>% select(-lsoa21) %>% select(`2021_prop_manufacturing`:`2001_prop_sick`, `2021_prop_unemployed`:`2001_prop_no_car` , .cluster)
str(pca_data)
pc <- prcomp(pca_data[,-28], center = TRUE, scale. = TRUE)
print(pc)
summary(pc)

biplot <- ggbiplot(pc, obs.scale = 1, var.scale = 1,
                   groups = pca_data$.cluster,
                   ellipse = TRUE,
                   circle = TRUE,
                   ellipse.prob = 0.68)
biplot <- biplot + scale_color_discrete(name = '')
biplot <- biplot + theme(legend.direction = 'horizontal',
                         legend.position = 'top')

biplot

# (3) Reconnect the data with the indices and represent in this space

index_data <- df_partition %>% select(lsoa21, .cluster) %>%
  right_join(Townsend_prepared %>% select(year:Townsend_index)) %>% #Warning generated by the way we filled in missing data
  right_join(Manufacturing_prepared %>% select(year:Manufacturing_index)) 

ggplot(index_data, aes(x = Manufacturing_index, y = Townsend_index, color = .cluster)) + geom_point() + facet_wrap(~year)

### DBSCAN ###

#install.packages("dbscan")
library("dbscan")

db_data <- as.matrix(df_partition %>% filter(str_detect(.cluster, "^1.")) %>% select(matches("^2021")))
db_data <- as.matrix(df_partition %>% filter(str_detect(.cluster, "^2.")) %>% select(matches("^2021")))
db_data <- as.matrix(df_partition %>% select(matches("^2021"))) 

data_inc_coords <- Birmingham_2021 %>% right_join(df_partition, by = c("LSOA21CD" = "lsoa21")) %>% st_drop_geometry()

db_data <- as.matrix(data_inc_coords %>% select(matches("^2021"), LONG, LAT)) 

kNNdistplot(db_data, k = 11, minPts = 12) # Used to inspect for knee/ eps value

db <- dbscan(db_data, eps = 0.10, minPts = 12)    # Area 1 - eps = 0.08 # Both - eps = 0.8 # Area 2 - eps = 0.15 #Adjust min to cols + 1
db

pairs(db_data, col = db$cluster + 1L)

## 

geographical_data <- Birmingham_2021 %>% right_join(df_partition, by = c("LSOA21CD" = "lsoa21")) 

geographical_data <- geographical_data %>% inner_join(augment(db, db_data), by = join_by(`2021_prop_manufacturing`, `2021_prop_Skilled`, `2021_prop_Unskilled`, `2021_prop_low_Edu`, `2021_prop_sick`,
                                                                                         `2021_prop_unemployed`, `2021_prop_Overcrowded`, `2021_prop_not_owned`, `2021_prop_no_car`))

dbscan_map <- tm_shape(geographical_data) + tm_fill(col = ".cluster.y", style = "cat", palette = "brewer.pu_or", col.legend = tm_legend(show = FALSE)) + tm_borders(alpha = 0.4) 

#tmap_save(partioned_map, 
#          filename = "~/R/Birmingham&Walsall/Poster_materials/partitioned_map.png",
#          width = 3000,
#          height = 3000,
#          dpi = 300)



##### Final check - Spatial autocorrelation - in data

neighbours <- poly2nb(geographical_data, queen = FALSE)
neighbours

#List of weights
listw <- nb2listw(neighbours)

# Are there spatial clusters in the proportion of people reporting ill-health
moran.test(geographical_data$`1981_prop_manufacturing`, listw)

# Moran plot

moran <- moran.plot(geographical_data$`1981_prop_manufacturing`, listw = nb2listw(neighbours, style = "W"))

# Local Moran output 

local <- localmoran(x = geographical_data$`1981_prop_manufacturing`, listw = nb2listw(neighbours, style = "W"))

# Add the relevant column to the  Birmingham Data
geographical_data <- cbind(geographical_data, Ii = local[,1])

# map local moran statistic 
tm_shape(geographical_data) + tm_fill("Ii", style = "quantile", title = "local moran statistic", palette = "brewer.pu_or") 



